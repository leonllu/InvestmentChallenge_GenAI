# -*- coding: utf-8 -*-
"""
Fetch point-in-time prices (04 Nov 2025, 16:15 Europe/Madrid) from Yahoo Finance,
convert to EUR, and print a tidy table.

Tickers:
- US: TSLA, NVDA, AMD (USD -> EUR)
- HK: 0700.HK (Tencent), 9988.HK (Alibaba) (HKD -> EUR)
- JP: 9984.T (SoftBank), 6861.T (Keyence) (JPY -> EUR)

Author: you :)
"""

import pandas as pd
import yfinance as yf
from datetime import datetime, timedelta
import pytz

# -----------------------------
# Configuration
# -----------------------------
TARGET_TZ = "Europe/Madrid"
TARGET_DT_LOCAL = datetime(2025, 11, 4, 16, 15)  # 04.11.2025 16:15 Barcelona/Madrid Zeit
LOOKBACK_MINUTES = 60  # wie weit in die Vergangenheit wir 1m-Daten laden (Sicherheitsfenster)
LOOKBACK_DAYS = 5      # Fallback: wie viele Tage zurück für den letzten Schlusskurs
INTERVAL = "1m"        # 1-Minuten-Kerzen für punktgenaue Preise

# Aktien-Ticker wie bei Yahoo Finance
# Portfolio basierend auf Investment Thesis: Tech/AI, Digitale Plattformen, Automation
TICKERS = {
    # USA - Tech & AI (50% allocation target)
    "TSLA": {"name": "Tesla", "ccy": "USD", "sector": "EV/Autonomous", "region": "US"},
    "NVDA": {"name": "NVIDIA", "ccy": "USD", "sector": "AI Hardware", "region": "US"},
    "AMD":  {"name": "AMD", "ccy": "USD", "sector": "Semiconductors", "region": "US"},
    "MSFT": {"name": "Microsoft", "ccy": "USD", "sector": "Cloud/AI", "region": "US"},
    "GOOGL": {"name": "Alphabet (Google)", "ccy": "USD", "sector": "AI/Search", "region": "US"},
    "AMZN": {"name": "Amazon", "ccy": "USD", "sector": "Cloud/E-commerce", "region": "US"},
    "META": {"name": "Meta", "ccy": "USD", "sector": "Social Media/AI", "region": "US"},
    
    # Hong Kong - Digital Platforms (30% allocation target)
    "0700.HK": {"name": "Tencent", "ccy": "HKD", "sector": "Gaming/Cloud", "region": "HK"},
    "9988.HK": {"name": "Alibaba", "ccy": "HKD", "sector": "E-commerce/Cloud", "region": "HK"},
    "1810.HK": {"name": "Xiaomi", "ccy": "HKD", "sector": "Consumer Tech", "region": "HK"},
    "3690.HK": {"name": "Meituan", "ccy": "HKD", "sector": "E-commerce/Delivery", "region": "HK"},
    
    # Japan - Automation & Innovation (20% allocation target)
    "9984.T":  {"name": "SoftBank", "ccy": "JPY", "sector": "Tech Investment", "region": "JP"},
    "6861.T":  {"name": "Keyence", "ccy": "JPY", "sector": "Automation/Robotics", "region": "JP"},
    "6758.T":  {"name": "Sony", "ccy": "JPY", "sector": "Entertainment/Tech", "region": "JP"},
    "7203.T":  {"name": "Toyota", "ccy": "JPY", "sector": "Automotive/EV", "region": "JP"},
    
    # ETFs für Diversifikation (10% allocation)
    "VWCE.DE": {"name": "Vanguard FTSE All-World", "ccy": "EUR", "sector": "Global ETF", "region": "EU"},
    "EQQQ.DE": {"name": "Invesco EQQQ Nasdaq-100", "ccy": "EUR", "sector": "Tech ETF", "region": "EU"},
}

# FX-Paare auf Yahoo Finance (notiert als <BASE><QUOTE>=X)
# Bedeutung: EURUSD=X -> USD pro EUR
# Um USD -> EUR zu konvertieren: EUR = USD / (USD pro EUR)
FX_TICKERS = {
    "USD": "EURUSD=X",  # USD per EUR
    "HKD": "EURHKD=X",  # HKD per EUR
    "JPY": "EURJPY=X",  # JPY per EUR
    "EUR": None,        # bereits EUR
}

# -----------------------------
# Helper
# -----------------------------
def localize_target_dt(dt_naive, tz_name):
    tz = pytz.timezone(tz_name)
    return tz.localize(dt_naive)

def get_last_price_at(ticker: str, target_dt_localized, lookback_minutes=60, interval="1m", fallback_days=5):
    """
    Lädt Intraday-Daten für ein Zeitfenster und gibt den letzten Kurs <= target_dt zurück.
    Fällt target_dt außerhalb der Handelszeiten, nimmt sie die letzte verfügbare Kerze davor.
    Falls keine Intraday-Daten verfügbar sind, wird auf Tageskerzen zurückgegriffen.
    """
    # History erwartet UTC-basierte Grenzen; yfinance akzeptiert Python datetime mit TZ
    start_dt = target_dt_localized - timedelta(minutes=lookback_minutes)
    end_dt = target_dt_localized + timedelta(minutes=1)  # kleines Polster

    df = yf.download(
        tickers=ticker,
        start=start_dt,
        end=end_dt,
        interval=interval,
        auto_adjust=False,  # wir wollen den echten Last-Preis der Kerze
        progress=False,
        threads=True,
    )

    if df.empty:
        # Fallback: versuche Tageskerzen für einen längeren Zeitraum
        start_dt_daily = target_dt_localized - timedelta(days=fallback_days)
        df = yf.download(
            tickers=ticker,
            start=start_dt_daily,
            end=end_dt,
            interval="1d",
            auto_adjust=False,
            progress=False,
            threads=True,
        )
        if df.empty:
            return None, None

    # yfinance liefert Index in UTC; wir konvertieren zum Vergleich in die Ziel-TZ
    # Check if already timezone-aware
    if df.index.tz is None:
        df = df.tz_localize("UTC").tz_convert(target_dt_localized.tzinfo)
    else:
        df = df.tz_convert(target_dt_localized.tzinfo)

    # Filter: alle Kerzen bis target_dt
    df = df[df.index <= target_dt_localized]

    if df.empty:
        return None, None

    # Nehme den letzten verfügbaren Close
    ts = df.index[-1]
    price = float(df["Close"].iloc[-1])
    return price, ts

def get_fx_rate_at(ccy: str, target_dt_localized, lookback_minutes=180, interval="1m", fallback_days=5):
    """
    Liefert den FX-Kurs 'CCY -> EUR' zum Zeitpunkt target_dt.
    Für EUR selbst = 1.0.
    Für USD/HKD/JPY verwenden wir EURXXX=X (XXX pro 1 EUR).
    Um XXX -> EUR zu rechnen: EUR = XXX / (XXX pro EUR)
    """
    if ccy == "EUR":
        return 1.0, None, None

    pair = FX_TICKERS.get(ccy)
    if pair is None:
        raise ValueError(f"Keine FX-Paar-Definition für {ccy}")

    rate, ts = get_last_price_at(pair, target_dt_localized, lookback_minutes, interval, fallback_days)
    if rate is None:
        return None, pair, None

    # Beispiel: EURUSD=X = 1.08 USD/EUR  -> USD -> EUR: USD / 1.08
    return (1.0 / rate), pair, ts  # Rückgabe: Faktor (CCY->EUR), FX-Ticker, Zeitstempel

# -----------------------------
# Main
# -----------------------------
def main():
    target_dt_local = localize_target_dt(TARGET_DT_LOCAL, TARGET_TZ)

    rows = []
    for y_ticker, meta in TICKERS.items():
        px, ts = get_last_price_at(y_ticker, target_dt_local, LOOKBACK_MINUTES, INTERVAL, LOOKBACK_DAYS)
        if px is None:
            rows.append({
                "Ticker": y_ticker,
                "Name": meta["name"],
                "Sector": meta["sector"],
                "Region": meta["region"],
                "Native Ccy": meta["ccy"],
                "Price (native)": None,
                "Price EUR": None,
                "Price TS (local)": None,
                "Yahoo URL": f"https://finance.yahoo.com/quote/{y_ticker}",
                "Note": "No intraday data returned for window",
            })
            continue

        fx_factor, fx_pair, fx_ts = get_fx_rate_at(meta["ccy"], target_dt_local, fallback_days=LOOKBACK_DAYS)
        if fx_factor is None:
            rows.append({
                "Ticker": y_ticker,
                "Name": meta["name"],
                "Sector": meta["sector"],
                "Region": meta["region"],
                "Native Ccy": meta["ccy"],
                "Price (native)": px,
                "Price EUR": None,
                "Price TS (local)": ts.strftime("%Y-%m-%d %H:%M"),
                "Yahoo URL": f"https://finance.yahoo.com/quote/{y_ticker}",
                "Note": f"FX missing for {meta['ccy']} (pair={fx_pair})",
            })
            continue

        rows.append({
            "Ticker": y_ticker,
            "Name": meta["name"],
            "Sector": meta["sector"],
            "Region": meta["region"],
            "Native Ccy": meta["ccy"],
            "Price (native)": round(px, 4),
            "Price EUR": round(px * fx_factor, 4),
            "Price TS (local)": ts.strftime("%Y-%m-%d %H:%M"),
            "FX Pair": fx_pair if fx_pair else "N/A",
            "FX TS (local)": fx_ts.strftime("%Y-%m-%d %H:%M") if fx_pair else "N/A",
            "Yahoo URL": f"https://finance.yahoo.com/quote/{y_ticker}",
        })

    df = pd.DataFrame(rows)
    # Sortiere nach Region und dann alphabetisch
    region_order = {"US": 1, "HK": 2, "JP": 3, "EU": 4}
    df["__region_ord"] = df["Region"].map(region_order)
    df = df.sort_values(["__region_ord", "Ticker"]).drop(columns="__region_ord").reset_index(drop=True)

    # Ausgabe
    pd.set_option("display.max_columns", None)
    print(df)

    # Optional: CSV speichern
    df.to_csv("prices_2025-11-04_1615_Europe-Madrid.csv", index=False)
    print("\nSaved: prices_2025-11-04_1615_Europe-Madrid.csv")

if __name__ == "__main__":
    main()

